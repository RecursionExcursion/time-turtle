Short answer: drop the class-as-data-wrapper. Keep your domain as **plain, JSON-safe data** and expose **pure helper functions** (a “model module”) to operate on it. Persist exactly that data. Keep persistence (compress/HMAC) in a thin repo/service. This removes all the mapping friction you’re feeling.

Below is a refactor that keeps your types, makes everything JSON-serializable, and gives you a clean functional API.

---

### 1) Domain = plain data (no classes)

```ts
// domain.ts
export type TimeTurtle = { users: User[] };

export type User = {
  info: UserInfo;
  time: {
    flags: string[];
    entries: TimeEntry[];
  };
};

export type UserInfo = { id: string; name: string; email: string };

export type TimeEntry = {
  id: string;
  inTime: number;           // epoch ms
  outTime?: number;         // epoch ms
  flags: string[];
};
```

### 2) “Model module” = pure functions over that data

```ts
// userModel.ts
import { v4 as uuidv4 } from "uuid";
import type { User, TimeEntry } from "./domain";

export const UserModel = {
  create(info: User["info"]): User {
    return { info, time: { flags: [], entries: [] } };
  },

  clone(u: User): User {
    return structuredClone(u);
  },

  createTimeEntry(u: User, ...flags: string[]): { user: User; entry: TimeEntry } {
    const entry: TimeEntry = { id: uuidv4(), inTime: Date.now(), flags };
    const user = UserModel.clone(u);
    user.time.entries.push(entry);
    return { user, entry };
  },

  closeTimeEntry(u: User, id: string): User {
    const user = UserModel.clone(u);
    const te = user.time.entries.find(e => e.id === id);
    if (te) te.outTime = Date.now();
    return user;
  },

  getOpenEntries(u: User): TimeEntry[] {
    return u.time.entries.filter(e => !e.outTime);
  },

  getLatestOpenEntry(u: User): TimeEntry | undefined {
    // If you target older runtimes, replace with manual scan
    return u.time.entries.findLast?.(e => !e.outTime) ??
           [...u.time.entries].reverse().find(e => !e.outTime);
  },

  getLastEntry(u: User): TimeEntry | undefined {
    return u.time.entries.at?.(-1) ?? u.time.entries[u.time.entries.length - 1];
  },

  getEntriesAfter(
    u: User,
    date: number,
    opts?: { closed?: boolean; open?: boolean; flags?: string[] }
  ): TimeEntry[] {
    return u.time.entries
      .filter(e => e.inTime > date || (e.outTime && e.outTime > date))
      .filter(e => (opts?.open ? !e.outTime : true))
      .filter(e => (opts?.closed ? !!e.outTime : true))
      .filter(e => (opts?.flags ? opts.flags.some(f => e.flags.includes(f)) : true));
  },
};
```

### 3) Persistence = thin repo/service (no class instances crossing the boundary)

```ts
// persistence.ts
import { v4 as uuidv4 } from "uuid";
import type { TimeTurtle } from "./domain";
import { compress, decompress } from "../service/compressionService";
import { generateHmac, validateHmac } from "../service/hmacService";

export type PersistenceBlob = {
  id: string;
  lastAccessed: number;
  hmac: string;
  data: string; // compressed payload
};

export interface Persister {
  save: (blob: PersistenceBlob) => void;
  read: () => PersistenceBlob | undefined;
}

export class TimeTurtleRepo {
  constructor(private readonly persister: Persister) {}

  async read(): Promise<TimeTurtle | undefined> {
    const blob = this.persister.read();
    if (!blob) return;

    const ok = await validateHmac(blob.data, blob.hmac);
    if (!ok) throw new Error("Invalid data");

    return decompress<TimeTurtle>(blob.data);
  }

  async save(state: TimeTurtle): Promise<void> {
    const data = await compress(state);
    const blob: PersistenceBlob = {
      id: uuidv4(),
      lastAccessed: Date.now(),
      hmac: await generateHmac(data),
      data,
    };
    this.persister.save(blob);
  }
}
```

### 4) Usage

```ts
import { TimeTurtleRepo } from "./persistence";
import { UserModel } from "./userModel";
import type { TimeTurtle, UserInfo } from "./domain";

const repo = new TimeTurtleRepo(localPersister);

// initialize
let app: TimeTurtle = (await repo.read()) ?? { users: [] };

// add user
const info: UserInfo = { id: "u1", name: "Ada", email: "ada@example.com" };
app.users.push(UserModel.create(info));

// add an entry
const { user: updated, entry } = UserModel.createTimeEntry(app.users[0], "coding");
app.users[0] = updated;

// close it
app.users[0] = UserModel.closeTimeEntry(app.users[0], entry.id);

// persist
await repo.save(app);
```

---

## Why this approach fits your pain points

* **No mapping churn**: Your persisted form and in-memory form are identical JSON. No “class to DTO” conversions.
* **No prototype revival**: You never need to “rehydrate” methods; functions live in modules, not on instances.
* **Go-like vibe**: It’s close to “structs + free functions with receivers” in Go. Think `UserModel.DoThing(user)` \~= `func (u *User) DoThing()`.
* **Easier testing**: Every function is pure (or returns a new copy). You can snapshot inputs/outputs easily.
* **Safer persistence**: You’re always saving plain data; no accidental leakage of methods/closures.

---

## If you *really* want a class API…

You can still provide a **facade** class that wraps a `User` *temporarily*, but don’t persist it. That keeps ergonomics without serialization headaches:

```ts
export class UserFacade {
  constructor(public u: User) {}

  createTimeEntry(...flags: string[]) {
    const res = UserModel.createTimeEntry(this.u, ...flags);
    this.u = res.user;
    return res.entry;
  }
  // etc…
}
// Use facade only at the call site; persist `User`, not `UserFacade`.
```

---

## Niceties you might add

* **Schema validation** (zod) at load boundaries.
* **Immutability helper** (Immer) if you like `draft` ergonomics.
* **Repo interface** for test doubles (in-memory persister).

---

### Bottom line

Go-style “structs + functions” maps perfectly to TS when your state must be serialized. Keep the data plain; put behavior in modules; make persistence a service. This will eliminate the clunky mapping you’re fighting with today.
